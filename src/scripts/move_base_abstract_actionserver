#!/usr/bin/python
import copy
import random
from sys import argv
from math import sqrt
import rospy
import actionlib
import tf
from move_base_msgs.msg import MoveBaseAction, MoveBaseActionFeedback,\
    MoveBaseActionResult
from geometry_msgs.msg import Pose, PoseStamped, PoseWithCovarianceStamped

if len(argv) > 1:
    simulator = argv[2]
else:
    simulator = "stage_ros"  # 'gazebo', 'stage_ros', or 'virtual_robots' (for Robot Highways)

if simulator == "gazebo":
    from gazebo_msgs.msg import ModelState

avg_speed = float(argv[3])  # m/s

# TODO:
#  - Add a probability that the robot will fail to reach the goal, and publish a result of 4 (aborted) if this happens.
#  - Move robot partway along its path at each iteration of the movement loop, or at least place it halfway between nodes when using `virtual_robots`
#     This will allow topological navigation to correctly detect the robot's "current edge".
#  - Use the maximum speed for the type of edge to be traversed in the topological map, rather than average speed, when using `virtual_robots`.
#  - Provide more information in move_base feedback and result.

namespace = rospy.get_namespace()

if simulator == "gazebo":
    pose_pub = rospy.Publisher('/gazebo/set_model_state', ModelState, queue_size=1)
elif simulator == "stage_ros":
    pose_pub = rospy.Publisher(namespace+'cmd_pose', Pose, queue_size=1)
elif simulator == "virtual_robots":
    tf_broadcaster = tf.TransformBroadcaster()
    rviz_pose_pub = rospy.Publisher(namespace+'robot_pose', Pose, queue_size=1)  # Topic for RViz to display goal pose
ground_truth_pose = Pose()


def ground_truth_pose_cb(msg):
    global ground_truth_pose
    if simulator == "virtual_robots":
        ground_truth_pose = msg
    else:
        ground_truth_pose = msg.pose.pose


class MoveBaseAbstractActionServer(object):
    _feedback = MoveBaseActionFeedback()
    _result = MoveBaseActionResult()

    def __init__(self):
        self.robot_name = argv[1]
        self.simulator = simulator
        self.avg_speed = avg_speed
        self.robot_start_pos_x = float(argv[4])
        self.robot_start_pos_y = float(argv[5])
        self.failure_probability = 0.01  # Probability that the robot will fail to reach the goal
        self.retry_delay = 5  # Seconds to wait before retrying a failed goal
        self.retry_count = 0
        self.max_retry_count = 3

        # If simulator == "virtual_robots", set the robot's initial position
        if self.simulator == "virtual_robots":
            # Broadcast the initial pose as a transform between the robot base_link and the map
            goal_pose = Pose()
            goal_pose.position.x = self.robot_start_pos_x
            goal_pose.position.y = self.robot_start_pos_y
            goal_pose.position.z = 0
            goal_pose.orientation.w = 1
            translation = (goal_pose.position.x, goal_pose.position.y, goal_pose.position.z)
            rotation = (goal_pose.orientation.x, goal_pose.orientation.y, goal_pose.orientation.z, goal_pose.orientation.w)
            tf_broadcaster.sendTransform(translation, rotation, rospy.Time.now(), namespace + "base_link", "map")

            # Publish goal pose to RViz
            rviz_pose_pub.publish(goal_pose)
            rospy.loginfo("Initial pose and transform published for Virtual Robots simulator")

        self._as = actionlib.SimpleActionServer("move_base", MoveBaseAction, self.execute_cb, False)
        self._as.start()

    def execute_cb(self, goal):
        rospy.loginfo("Received goal: {}".format(goal))

        # Random chance for movement to the goal to fail
        if random.random() <= self.failure_probability:
            if self.retry_count >= self.max_retry_count:
                # Define and publish result
                self._result = MoveBaseActionResult()
                self._result.header.stamp = rospy.Time.now()
                self._result.header.frame_id = "map"
                self._result.status.status = 4
                self._result.status.text = "Goal failed to be reached after {} of {} retries".format(self.retry_count, self.max_retry_count)
                rospy.logerr("Goal failed to be reached after {} of {} retries".format(self.retry_count, self.max_retry_count))
                rospy.logerr("Aborting goal")
                self._as.set_aborted(self._result)
                return
            else:
                self._result.status.text = "Goal failed to be reached after {} of {} retries".format(self.retry_count, self.max_retry_count)
                rospy.logwarn("Goal failed to be reached after {} of {} retries".format(self.retry_count, self.max_retry_count))
                rospy.logwarn("Retrying goal after {} second wait".format(self.retry_delay))
                rospy.sleep(self.retry_delay)
                self.retry_count += 1
                self.execute_cb(goal)

        else:
            self.goal_pose_cb(goal.target_pose.pose)

            # Define and publish result
            self._result = MoveBaseActionResult()
            self._result.header.stamp = rospy.Time.now()
            self._result.header.frame_id = "map"
            self._result.status.status = 3
            self._result.status.text = "Goal reached"
            # self._result.result.base_position = ground_truth_pose
            self._as.set_succeeded(self._result)
            self.retry_count = 0



    def goal_pose_cb(self, msg):
        goal_pose = msg
        if simulator == "gazebo":
            model_state = ModelState()
            model_state.model_name = namespace.strip("/")
            model_state.pose = goal_pose
            rospy.loginfo("Model state pose msg type: {}".format(type(model_state.pose)))
        rospy.loginfo("Goal pose received: %s", goal_pose)

        # Calculate the distance to the goal
        distance = sqrt(((goal_pose.position.x - ground_truth_pose.position.x)**2) +
                        ((goal_pose.position.y - ground_truth_pose.position.y)**2))
        time_to_goal = distance / avg_speed
        rospy.loginfo("Distance to goal: %s", distance)
        rospy.loginfo("Robot will reach the goal in %s seconds", time_to_goal)
        time_taken_to_goal = 0.0
        time_remaining_to_goal = time_to_goal

        # If simulator == "virtual_robots", set the robot's position as halfway between the current position and the goal.
        #  This is to simulate the robot's presence on the edge between its current node and the goal node on the topological map
        if self.simulator == "virtual_robots":
            halfway_pose = Pose()
            halfway_pose.position.x = (goal_pose.position.x + ground_truth_pose.position.x) / 2
            halfway_pose.position.y = (goal_pose.position.y + ground_truth_pose.position.y) / 2
            halfway_pose.position.z = 0
            halfway_pose.orientation.w = 1
            translation = (halfway_pose.position.x, halfway_pose.position.y, halfway_pose.position.z)
            rotation = (halfway_pose.orientation.x, halfway_pose.orientation.y, halfway_pose.orientation.z, halfway_pose.orientation.w)
            tf_broadcaster.sendTransform(translation, rotation, rospy.Time.now(), namespace + "base_link", "map")

            # Publish halfway pose to RViz
            rviz_pose_pub.publish(halfway_pose)
            rospy.loginfo("Halfway pose and transform published for Virtual Robots simulator")

        # Publish the goal pose, and cancel if preempted during travel to goal
        while time_remaining_to_goal > 0.0:
            # rospy.loginfo("Time remaining to goal: %s", time_remaining_to_goal)
            if time_remaining_to_goal < 0.5:
                if self._as.is_preempt_requested():
                    self._as.set_preempted()
                    rospy.loginfo("Goal cancelled")
                    return
                rospy.sleep(time_remaining_to_goal)
                time_remaining_to_goal = 0.0
            else:
                if self._as.is_preempt_requested():
                    self._as.set_preempted()
                    rospy.loginfo("Goal cancelled")
                    return
                rospy.sleep(0.5)
                time_taken_to_goal += 0.5
                time_remaining_to_goal = time_to_goal - time_taken_to_goal

        if simulator == "gazebo":
            pose_pub.publish(model_state)

        elif simulator == "stage_ros":
            offset_goal = copy.deepcopy(msg)
            offset_goal.target_pose.pose.position.x = offset_goal.target_pose.pose.position.x - 162.0
            offset_goal.target_pose.pose.position.y = offset_goal.target_pose.pose.position.y - 110.0

            goal_pose = Pose()
            goal_pose.position.x = offset_goal.target_pose.pose.position.x
            goal_pose.position.y = offset_goal.target_pose.pose.position.y
            goal_pose.orientation.w = 1.0

            pose_pub.publish(goal_pose)

        elif simulator == "virtual_robots":
            # Broadcast the goal pose as a transform between the robot base_link and the map
            translation = (goal_pose.position.x, goal_pose.position.y, goal_pose.position.z)
            rotation = (goal_pose.orientation.x, goal_pose.orientation.y, goal_pose.orientation.z, goal_pose.orientation.w)
            tf_broadcaster.sendTransform(translation, rotation, rospy.Time.now(), namespace + "base_link", "map")

            # Publish goal pose to RViz
            rviz_pose_pub.publish(goal_pose)
        rospy.loginfo("Goal pose published to " + simulator)


    def move_base_goal_cb(self, msg):
        goal_pose = msg.goal.target_pose.pose
        self.goal_pose_cb(goal_pose)


def move_base_simple_goal_cb(msg):
    goal_pose = msg.pose
    server.goal_pose_cb(goal_pose)


if __name__ == '__main__':
    rospy.Subscriber(namespace+'move_base_simple/goal', PoseStamped, move_base_simple_goal_cb)
    if simulator == "virtual_robots":
        rospy.Subscriber(namespace+'robot_pose', Pose, ground_truth_pose_cb)
    else:
        rospy.Subscriber(namespace+'amcl_pose', PoseWithCovarianceStamped, ground_truth_pose_cb)
    rospy.init_node('move_base_abstract_actionserver')
    server = MoveBaseAbstractActionServer()
    
    rospy.loginfo("Started move_base_abstract_actionserver node with args:\n"\
                  "Robot name: {}\n" \
                  "Simulator: {}\n" \
                  "Average speed: {}\n" \
                  "Robot start position x: {}\n" \
                  "Robot start position y: {}\n".format(argv[1], argv[2], argv[3], argv[4], argv[5])
    )
    rospy.spin()
